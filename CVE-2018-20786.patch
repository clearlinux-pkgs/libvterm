From 40373d49835e76b8e9528ebda4794791ab395629 Mon Sep 17 00:00:00 2001
From: Karthik Prabhu Vinod <karthik.prabhu.vinod@intel.com>
Date: Mon, 14 Sep 2020 16:29:04 -0700
Subject: [PATCH] patch 8.1.0633: crash when out of memory while opening a
 terminal window

Problem:    CVE-2018-20786: Crash when out of memory while opening a terminal window.
Solution:   Handle out-of-memory more gracefully.

Fixes CVE-2018-20786

Looks like real patch https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8
could not be cleanly back-ported. So I chose to cherry-pick those changes from that commit
to 0.1.4 version present in clearlinux distro
---
 src/screen.c | 21 +++++++++++++++------
 src/state.c  |  8 ++++++++
 src/vterm.c  | 20 +++++++++++++++++++-
 3 files changed, 42 insertions(+), 7 deletions(-)

diff --git a/src/screen.c b/src/screen.c
index 19cf384..c41dfc1 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -1,5 +1,6 @@
 #include "vterm_internal.h"
 
+/* vim: set sw=2 : */
 #include <stdio.h>
 #include <string.h>
 
@@ -94,8 +95,7 @@ static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int n
     }
   }
 
-  if(buffer)
-    vterm_allocator_free(screen->vt, buffer);
+  vterm_allocator_free(screen->vt, buffer);
 
   return new_buffer;
 }
@@ -517,8 +517,7 @@ static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)
   screen->rows = new_rows;
   screen->cols = new_cols;
 
-  if(screen->sb_buffer)
-    vterm_allocator_free(screen->vt, screen->sb_buffer);
+  vterm_allocator_free(screen->vt, screen->sb_buffer);
 
   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);
 
@@ -619,6 +618,10 @@ static VTermStateCallbacks state_cbs = {
   .setlineinfo = &setlineinfo,
 };
 
+/*
+ * Allocate a new screen and return it.
+ * Return NULL when out of memory.
+ */
 static VTermScreen *screen_new(VTerm *vt)
 {
   VTermState *state = vterm_obtain_state(vt);
@@ -626,6 +629,8 @@ static VTermScreen *screen_new(VTerm *vt)
     return NULL;
 
   VTermScreen *screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));
+  if (screen == NULL)
+    return NULL;
   int rows, cols;
 
   vterm_get_size(vt, &rows, &cols);
@@ -648,6 +653,11 @@ static VTermScreen *screen_new(VTerm *vt)
   screen->buffer = screen->buffers[0];
 
   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);
+  if (screen->buffer == NULL || screen->sb_buffer == NULL)
+  {
+    vterm_screen_free(screen);
+    return NULL;
+  }
 
   vterm_state_set_callbacks(screen->state, &state_cbs, screen);
 
@@ -657,8 +667,7 @@ static VTermScreen *screen_new(VTerm *vt)
 INTERNAL void vterm_screen_free(VTermScreen *screen)
 {
   vterm_allocator_free(screen->vt, screen->buffers[0]);
-  if(screen->buffers[1])
-    vterm_allocator_free(screen->vt, screen->buffers[1]);
+  vterm_allocator_free(screen->vt, screen->buffers[1]);
 
   vterm_allocator_free(screen->vt, screen->sb_buffer);
 
diff --git a/src/state.c b/src/state.c
index 9108009..d120702 100644
--- a/src/state.c
+++ b/src/state.c
@@ -52,6 +52,8 @@ static VTermState *vterm_state_new(VTerm *vt)
 {
   VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));
 
+  if (state == NULL)
+    return NULL;
   state->vt = vt;
 
   state->rows = vt->rows;
@@ -1697,12 +1699,18 @@ static const VTermParserCallbacks parser_callbacks = {
   .resize  = on_resize,
 };
 
+/*
+ * Return the existing state or create a new one.
+ * Returns NULL when out of memory.
+ */
 VTermState *vterm_obtain_state(VTerm *vt)
 {
   if(vt->state)
     return vt->state;
 
   VTermState *state = vterm_state_new(vt);
+  if (state == NULL)
+    return NULL;
   vt->state = state;
 
   state->combine_chars_size = 16;
diff --git a/src/vterm.c b/src/vterm.c
index afb9e33..6cb45f0 100644
--- a/src/vterm.c
+++ b/src/vterm.c
@@ -1,3 +1,4 @@
+/* vim: set sw=2 : */
 #include "vterm_internal.h"
 
 #include <stdio.h>
@@ -37,6 +38,8 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun
   /* Need to bootstrap using the allocator function directly */
   VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);
 
+  if (vt == NULL)
+    return NULL;
   vt->allocator = funcs;
   vt->allocdata = allocdata;
 
@@ -51,6 +54,11 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun
   vt->parser.strbuffer_len = 64;
   vt->parser.strbuffer_cur = 0;
   vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);
+  if (vt->parser.strbuffer == NULL)
+  {
+    vterm_allocator_free(vt, vt);
+    return NULL;
+  }
 
   vt->outfunc = NULL;
   vt->outdata = NULL;
@@ -58,6 +66,12 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun
   vt->outbuffer_len = 64;
   vt->outbuffer_cur = 0;
   vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);
+  if (vt->outbuffer == NULL)
+  {
+    vterm_allocator_free(vt, vt->parser.strbuffer);
+    vterm_allocator_free(vt, vt);
+    return NULL;
+  }
 
   vt->tmpbuffer_len = 64;
   vt->tmpbuffer = vterm_allocator_malloc(vt, vt->tmpbuffer_len);
@@ -85,9 +99,13 @@ INTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)
   return (*vt->allocator->malloc)(size, vt->allocdata);
 }
 
+/*
+ * Free "ptr" unless it is NULL.
+ */
 INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)
 {
-  (*vt->allocator->free)(ptr, vt->allocdata);
+  if (ptr)
+    (*vt->allocator->free)(ptr, vt->allocdata);
 }
 
 void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)
-- 
2.28.0

